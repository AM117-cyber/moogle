# Moogle!

![](moogle.png)

> Proyecto de Programación I. Facultad de Matemática y Computación. Universidad de La Habana.   

Nombre: Ana Melissa Alonso Reina.
Grupo: C-112.

Con el objetivo de que el programa realizara una búsqueda inteligente y devolviera los resultados de esta ordenados por su relevancia de mayor a menor, se utilizó un modelo vectorial, puesto que este da precisamente un valor de acuerdo al grado de similitud de un documento respecto a la consulta(query). Para obtener el grado de similitud se calculó el coseno del ángulo comprendido entre dos vectores(documento, query), cuya fórmula es  

En la cual tanto el query como el documento son vectores formados por los valores de TF-IDF de cada una de sus palabras. Por lo tanto, para poner en práctica esta función de ranking del modelo vectorial fue necesario calcular el TF-IDF de cada palabra por documento y el TF-IDF de cada palabra del query.Ver(1)
Una vez obtenido cada TF-IDF y asociado cada resultado de la función ranking con su documento en cuestión se ordenan hasta los 10 primeros resultados de mayor a menor para mostrarle un snippet-con una vecindad de la palabra de mayor importancia(TF-IDF) del query- de ellos al usuario; en caso de que la cantidad de resultados de la búsqueda sea inferior a 4 se verifica si hay alguna palabra del query que no aparezca en ningún documento, luego se halla la mayor similitud entre esa palabra ausente de los documentos y todas las palabras de los documentos para obtener un término que sea lo más similar posible a aquel introducido en el query pero que sí aparezca en alguno de los documentos entre los que buscamos; esto nos permitirá sugerirle un nuevo query al usuario con el fin de que al utilizar esta sugerencia en su búsqueda obtenga más resultados que los obtenidos con el anterior query y a la vez, permitirá brindar una sugerencia al usuario en caso de que ingrese un término mal escrito, siempre que los resultados de la búsqueda  sean inferiores a 4. Es necesario mencionar que los documentos sobre los cuales se realizará la búsqueda son procesados al inicio del programa para evitar prolongar el tiempo de búsqueda. 
Hay tres operadores que son adicionados con el fin de darle más control al usuario sobre los resultados de la búsqueda. Estos son:
! – Si este operador aparece delante de una palabra del query entonces antes de calcular la similitud entre un documento y el query se verifica que la palabra en cuestión no aparezca en el documento, en caso contrario, a ese documento se le asociaría una similitud de 0 con el query,puesto que no puede ser devuelto como resultado de la búsqueda.
^ -Si este operador aparece delante de una palabra del query entonces igual que con el operador anterior verificamos si la palabra aparece en el documento, solo que en caso de no aparecer es que le adjudicamos una similitud de 0 al documento con el query, puesto que la palabra debe aparecer en el documento como requisito para que sea un resultado válido.
* - Si este operador aparece delante de una palabra del query se incrementa el TF de ella tantas veces como aparezca dicho operador frente a la misma, este procedimiento se hace antes de sacar el TF-IDF de cada elemento del query, aumentando por lo tanto la importancia de la palabra a la cual se le aplica este operador, lo que será tomado en cuenta en el cálculo de la similitud entre un documento y el query.
~ - Si este operador aparece entre dos o más palabras del query, se halla mediante los índices de las mismas la menor distancia entre ellas por documento. El resultado de dividir 1 entre este valor se suma a la similitud del documento correspondiente, puesto que lo que se pretende es otorgarle una mayor importancia(score) a los documentos mientras mayor sea la cercanía entre las palabras del query unidas por este operador.
Clase Document
En esta clase se define un tipo de variable que representa a un documento, teniendo entre sus propiedades título, cantidad total de palabras, su contenido(representado con un diccionario en el cual a cada palabra se le hace corresponder su TermData) y su norma.
Clase TermData
En esta clase se define el tipo de variable TermData que representa los términos de un mismo documento, por lo cual tienen un TF,TF-IDF, así como los índices en los que aparece ese término en el documento entre sus propiedades.
Clase DocumentProcessor
 
En esta clase está el método ProcessFolder, el cual recibe una string[] conteniendo las direcciones de cada uno de los documentos en la carpeta Content para procesarlos con el método ProcessText y devolver cada uno de los documentos una vez procesados utilizando yield return.
En este método recibe dos string: el texto del documento y el patrón por el cual se utilizará Regex.Matches sobre el documento. Regex.Matches devuelve una colección de Match que consiste en cada elemento que cumplía con el patrón \w+ con su índice, por esta razón utilizo Regex.Matches para quedarme solo con los caracteres que son alfanuméricos del texto y con el índice de cada uno, debido a que estos son los únicos que tienen relevancia la hora de realizar la búsqueda. Una vez hecho esto aplico sobre cada elemeto de MatchCollection una normalización con esta línea de código:
string word_modified = Regex.Replace(word.Value.ToLower().Normalize(NormalizationForm.FormD), @"[^a-zA-Z0-9 ]+", "");
 
Que guarda en un nuevo string a la palabra original llevados todos sus caracteres a minúscula y eliminando las tildes, dierésis y ~ de las ñ para que la presencia de estos caracteres y el uso de mayúsculas y minúsculas no afecte la búsqueda. Dentro de ProcessText también obtenemos el TF y una lista con sus índices para cada palabra del texto que analizamos, lo cual podemos hacer porque al inicio del método creamos un Dictionary<string, TermData> cuyas llaves son las palabras del documento después de haber sido normalizadas y el valor que le corresponde a cada una es una variable de tipo TermData, a la cual le incrementamos su TF y añadimos otro valor a su lista de índices cada vez que su llave(palabra normalizada) se repita en el documento.
En esta clase también está el objeto IDF, que es un Dictionary<string, double> en el cual se guardan las distintas palabras del conjunto de documentos con su IDF mediante el método GetIDF, el cual no recibe ningún dato porque no se ejecuta sobre una instancia, sino sobre el conjunto de documentos. En este método se itera por los documentos y por el contenido de cada uno, de modo que cada vez que se pase por un término diferente en un documento se incorpore dicho término como llave del diccionario IDF y se le asocie un valor de 1, en caso de que el término ya sea una llave de IDF se le suma uno a su valor. De esta forma se obtiene la cantidad de documentos en la que aparece cada término-DF-, por lo que luego se le asocia a cada término el logaritmo en base 10 del resultado de dividir el total de documentos entre el DF del término, teniendo finalmente cada término con su IDF.
Como ya tenemos el TF y el IDF de cada palabra podemos calcular el TF-IDF.Para esto se utiliza el método SettingEachTFIDF, en el cual se itera por los documentos de cada término dándole valor al TF-IDF de su TermData que había sido inicializado en 0. Para esto se divide el TF del término entre la cantidad de palabras del documento y esto se multiplica por el IDF de dicho término.
Con el método ProcessQuery se procesa el texto del query ingresado por el usuario llamando al método ProcessText y se devuelve un Dictionary<string, TermData>. Luego con el método GetTFIDF se obtiene el TF-IDF de cada palabra del query, iterando por cada una de ellas y dividiendo el TF entre la cantidad de palabras del documento para multiplicar el resultado por el IDF del término.

Clase Similarity
En esta clase se encuentra el método SimilarityThreshold, que recibe el query original y el query procesado, es decir, el Dictionary<string, TermData> que da como resultado ProcessText. En este método se construye un Dictionary<Document,float> llamado Coincidences que tendrá como llaves a los documentos que el usuario recibirá como resultado de su búsqueda; como el query puede tener operadores que influirán en estos resultados, lo primero que se hace es revisar si alguno de estos operadores fue utilizado en el query.
Abajo se utilizan tres foreach(uno para cada operador, exceptuando el de cercanía), los cuales se ejecutan solo si el operador que le corresponde es utilizado en el query. En el foreach que itera por cada una de las palabras que tengan asteriscos frente a ellas, se obtiene el número de asteriscos frente a cada palabra y se incrementa el TF de acuerdo al número de asteriscos utilizados. Luego se llama al método GetTFIDF de la clase DocumentProcessor y se calcula la norma del vector query con el método VectorNorm(ver 7 líneas más abajo), método que recibe un Dictionary<string, TermData> y  suma cada uno de los cuadrados de los TF-IDF de cada llave del diccionario y devuelve la raíz cuadrada de esta suma. 
En los otros dos foreach se le da un valor de 0 a la similitud entre el documento y el query, en dependencia del operador utilizado; en caso de utilizar el operador ! si la palabra que viene a continuación de él en el query aparece en el texto, su similitud con el query es de 0 y de utilizar el operador ^, si el documento no contiene la palabra que acompaña al operador su similitud también es de 0.
Luego por cada documento se declara una variable que guarda el resultado del método ClosenessOperatorInfluence , el cual utiliza Regex.Matches y el método FixMatches(elimina el operador de cercanía y los espacios entre las palabras a las cuales se les aplica este operador) para que si un documento contiene a ambas palabras y esas palabras son distintas calcular la menor distancia entre ellas en ese documento con el método GetShortestDistance. ClosenessOperatorInfluence devuelve el resultado de dividir entre 1 el producto del double obtenido en GetShortestDistance y la norma del query por la norma del documento. Lo que devuelve este método es guardado en la variable closeness, la cual se suma a la similitud entre dos documentos que se halla por la fórmula del coseno, para obtener la similitud total entre documento y query. Este valor de similitud se le asocia al documento en un diccionario en el cual a cada documento le corresponde su similitud con el query, diccionario que es ordenado por sus valores de mayor a menor en el método Query de la clase Moogle, para guardar en la variable resultado sus 10 primeros elementos. En el método WordsForSuggestion de la clase Similarity se comprueba si hay alguna palabra del query que no aparezca en los documentos con el método WordExists y se guardan en una lista todas las palabras del query que devuelvan falso a WordExists. El método GetSuggestions recibe esta lista y encuentra entre todos sus elementos cuál tiene mayor similitud con otra palabra de los documentos, devolviendo una dupla de strings con la palabra del query y su sugerencia. En el método Query de la clase Moogle solo se llama a este método si el número de los resultados de la búsqueda es menor que 4 y la lista devuelta por WordsForSuggestion no está vacía. Entonces, con la dupla devuelta por GetSuggestions se sustituye en el query la primera palabra de la dupla por la palabra sugerida(segunda de la dupla) para devolverle una sugerencia al usuario. 
Al final de la clase Similarity se encuentra el método SimilarityBetweenWords que utiliza la distancia de Levenshtein para determinar el número de cambios necesarios para convertir la palabra de la búsqueda en otra y le resta este número al total de letras de la palabra del query para obtener su similitud con la otra.
Clase Moogle
Además del método mencionado anteriormente, en esta clase se encuentra el método GetSnippet, el cual determina por documento qué palabra del query tiene más peso en él para mostrar un fragmento del documento que contenga a esta palabra.Dentro de este método se llama a otro llamado FindRange, que devuelve los índices del inicio y fin por documento para asegurarse de que ninguna palabra quede incompleta en los extremos del snippet. Luego, cada elemento del query se coloca en una lista utilizando Regex.Matches, ordenamos los elementos de esta lista por sus índices de mayor a menor e insertamos la líneas "</span>"
Al final y "<span style=\"background-color:yellow\">"
 al inicio de la palabra respectivamente.
El último método de esta clase es Initialize, que está al inicio del buscador, el cual no puede comenzar la búsqueda a menos que todos los documentos hayan sido procesados de antemano.
Este método en Index.razor se ejecuta cuando el programa está listo para empezar y lo que hace es llamar al método Initialize.
protected override void OnInitialized()
    {
        Moogle.Initialize();   
    }


